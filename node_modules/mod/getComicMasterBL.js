/**************************************************************************************************
 * モジュール名　: 漫画マスタ情報取得ビジネスロジック
 * 概要　　　　　: 漫画マスタ情報を取得する
 *************************************************************************************************/

// モジュール読み込み
var client = require('cheerio-httpcli'),
    Q = require('q'),
    constComic = require("mod/constComic"),
    logger = require('mod/logger');

// 定数
var ARY_REQ_INFO = constComic.ARY_REQ_INFO;

exports.initProc = function(){
  // 処理開始
  logger.info("getComicMaster START");
};

exports.endProc = function(){
  // 処理開始
  logger.info("getComicMaster END");
};

exports.getComicList = function(in_comicList){

  var _d = Q.defer();
  var _arg = {
    idx : 0,
    comicList : []
  };
  var _q = Q.when(_arg);

  for(var i=0, len=ARY_REQ_INFO.length;i<len;i++){
    _q = _q.then(getComicInfo);
  }
  _q.done(function(){
    _d.resolve(_arg.comicList);
  });
  return _d.promise;
};

function getComicInfo(in_args){

  var _d = Q.defer();

  // リクエスト情報
  var _reqInfo = ARY_REQ_INFO[in_args.idx];

  // スクレイピング開始
  client.fetch(_reqInfo.url, {}, function(_e, $, _res) {

    // 正常終了の場合のみ情報を取得する
    if (!_e && _res.statusCode === 200) {
      // 取得結果からコミック情報を抽出
      in_args.comicList = in_args.comicList.concat(extractComicInfo($, _reqInfo));
    }else{
      // エラーが発生している、またはレスポンスコードが200以外の場合はエラー処理
      logger.error("getComicMaster Bad Request");
    }
    in_args.idx++;
    _d.resolve(in_args);
  });

  return _d.promise;
}

/**************************************************************************************************
 * 関数名　: 漫画情報抽出処理
 * 概要　　: スクレイピングの結果から必要な漫画情報のみ抽出する
 *************************************************************************************************/
function extractComicInfo($, in_reqInfo){

  var _upsertComicList = [];  // 更新対象コミック情報格納用

  // タイトル・作者・出版社を抽出
  $("ul").each(function(_idx){
    // 取得対象範囲内か判定
    if(in_reqInfo.idxF <= _idx && _idx <= in_reqInfo.idxT){
      // liが１件分のコミック情報を保持している。１冊ずつ必要な情報を抽出する
      var $li = $(this).find("li");
      $li.each(function(){

        var _title = $(this).find("a").eq(0).text(),  // タイトル
            _publisher = "",  // 出版社
            _author = ""; // 作者
        // 出版社・作者抽出用
        var _etc = $(this).text().substr(_title.length)
            .split("　").join("")
            .split(" ").join("")
            .slice(1, -1),
            _aryEtc = _etc.split("、");
        // 出版社が登録されているコミックとされていないコミックを配列の要素数で判定
        if(_aryEtc.length > 1){
          // 出版社と作者を取得
          _publisher = _aryEtc[_aryEtc.length - 1];
          _aryEtc.pop();
          _author = _aryEtc.join(" ");
        }else{
          // 作者を取得
          _author = _etc;
        }
        // 全角スペースは半角スペースに置換
        _title = _title.split("　").join(" ");
        _publisher = _publisher.split("　").join(" ");
        _author = _author.split("　").join(" ");
        // 空白をトリムしたタイトルと作者を検索用のキーとして作成
        var _key = _title.split(" ").join("") + "|" + _author.split(" ").join("");
        _key = _key.toLowerCase();

        // 更新対象として保存
        _upsertComicList.push({
          title:_title,
          publisher:_publisher,
          author:_author,
          key:_key
        });
      });
    }
  });

  return _upsertComicList;
}

exports.getComicListFromSales = function(in_comicList, db){

  var _d = Q.defer();

  Q().then(function(){
    var _d2 = Q.defer();
    db.open(function(_e, db){
      if(_e){
        _d2.reject(_e);
      }
      // 当月1日以降に発売される新刊を取得
      var collection = db.collection("salesinfos");
      var date = new Date(),
          year = date.getFullYear()+"",
          month = date.getMonth()+1+"";
      month = ("0" + month).slice(-2);

      // 取得したコミックからマスタ情報を抽出
      collection.find({
        salesDate:{
          "$gte" : makeGMTDate(year+month+"01")
        }
      }).toArray(function(err, results) {
        for(var i=0,len=results.length;i<len;i++){
          var comic = results[i];
          var aryTitle = comic.title.split(" ");
          var masterTitle="";
          if(aryTitle[aryTitle.length-1].slice(-1) === "版"){
            aryTitle.pop();
          }
          if(!isNaN(aryTitle[aryTitle.length-1])){
            aryTitle.pop();
            masterTitle = aryTitle.join(" ");
          }else{
            masterTitle = comic.title;
          }
          var masterKey = masterTitle.split(" ").join("") + "|" + comic.author.split(" ").join("");
          masterKey = masterKey.toLowerCase();
          in_comicList.push({
            title : masterTitle,
            publisher : comic.publisher,
            author : comic.author,
            key : masterKey
          });
        }
        _d2.resolve();
      });
    });
    return _d2.promise;
  })
  .fail(function(_e){
    _d.reject(_e);
  })
  .done(function(){
    db.close();
    _d.resolve(in_comicList);
  });
  return _d.promise;
};

exports.saveComicList = function(in_comicList, db){

  var _d = Q.defer();

  Q().then(function(){

    var _d2 = Q.defer();
    // DBへの接続
    db.open(function(_e, db){
      if(_e){
        _d2.reject(_e);
      }

      if(in_comicList.length > 0){

        // コレクションを指定
        var collection = db.collection("comics");
        var _args = {
          idx : 0,
          comicList : in_comicList,
          collection : collection
        };
        var _q = Q.when(_args);
        for(var _i=0,_len=in_comicList.length;_i<_len;_i++){
          _q = _q.then(upsertComic);
        }
        _q.done(function(){
          _d2.resolve();
        });
      }else{
        logger.warn("getComicMaster No List");
        _d2.resolve();
      }
    });
    return _d2.promise;
  })
  .fail(function(_e){
    _d.reject(_e);
  })
  .done(function(){
    db.close();
    _d.resolve();
  });

  return _d.promise;
};

function upsertComic(in_args){
  var _d = Q.defer();
  var _comic = in_args.comicList[in_args.idx];
  in_args.collection.update({
    title:_comic.title},
    _comic,
    {upsert:true},
    function(_e){
      if(_e){
        logger.warn(_e.message);
      }
      in_args.idx++;
      _d.resolve(in_args);
    }
  );
  return _d.promise;
}

function makeGMTDate(strYMD){
  var year = strYMD.substr(0, 4),
      month = strYMD.substr(4, 2),
      day = strYMD.substr(6, 2);
  return new Date(year + "-" + month + "-" + day + "T00:00:00.000+09:00");
}
